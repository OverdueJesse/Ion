#
struct Wolf {}
struct Sheep {
    fn new(name: string) => this {
        Sheep { name }
    }
}
shared isAnimal {
    // this is optional
    name?: string = "No Name :(";
    fn get_name() => string { // optional type declaration
        name
    }
    fn make_sound () => nil;
}
impl shared isAnimal on Wolf {
    fn make_sound () {
        println("awoooo");
    }
}
impl shared isAnimal on Sheep {
    name = "Dolly";
    fn make_sound () {
        println("bahhh");
    }
}
fn main () {
    let wolf = Wolf {
        name: "Jake",
    };
    let sheep = Sheep {};
    let animal = nil;
    animal = Sheep::new("Cindy");
    if animal {
        animal.make_sound();
    }
}
let test = 5;
let test2 = 5 + (test * 2);

on one
for forget

re return returning


let test1: number = 10;
let test2 := 5;


match test {
    _ => return 5,
}

test | 2 || 12 && test2

let ğŸ˜€ = "ğŸ˜€";
->
// comment at end [0 .. s.len()] 
0..10
0 .. 10
#





// real test code
let test = 5;
let test2 = 10;

let test3 = 10 - 5;







